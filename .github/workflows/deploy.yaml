name: Deploy to EKS

on:
  push:
    branches:
      - main  # Se ejecuta cada vez que haces push a la rama main

permissions:
  id-token: write # Necesario para OIDC (El pase de invitado) üõ°Ô∏è Pide permiso a GitHub para firmar un "Token JWT".
  contents: read # Permiso para leer tu c√≥digo.

jobs:
  deploy:
    runs-on: ubuntu-latest # üíª La computadora virtual: GitHub nos presta un servidor Linux (Ubuntu) fresco y vac√≠o.
    steps:
      - name: üì• Checkout Code
        uses: actions/checkout@v4
    
      # --- PASO 1: LINTING DE AUDITOR√çA (NO BLOQUEANTE) ---
      - name: üõ°Ô∏è Linting & Security Scan
        id: linter_step
        continue-on-error: true # <--- ESTO ES LO QUE SOLUCIONA TODO
        run: |
          # 1. Descargar binario
          curl -L https://github.com/stackrox/kube-linter/releases/download/v0.6.8/kube-linter-linux -o kube-linter
          chmod +x kube-linter
          
          # 2. Ejecutar escaneo
          # Mostrar√° los errores de 'root' y 'read-only', pero permitir√° que el pipeline SIGA.
          ./kube-linter lint amazon-generated.yaml

      # --- PASO 2: AUTENTICACI√ìN Y CONEXI√ìN ---
      - name: üîê Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }} # Usamos el secreto que guardaste
          aws-region: us-east-1

      - name: ‚ò∏Ô∏è Install kubectl
        uses: azure/setup-kubectl@v4
        with:
          version: 'latest'

      - name: üîå Update Kubeconfig
        run: |
          aws eks update-kubeconfig --name cluster-sre-demo --region us-east-1

      # --- PASO 3: EXTRACCI√ìN DE DATOS (FILTRANDO EL DEPLOYMENT) ---
      - name: üìä Extract Resource Specs
        id: specs
        run: |
          # Usamos un filtro para seleccionar solo el objeto 'Deployment'
          # Esto evita que yq lea los separadores '---' o el Service/Ingress
          CPU_REQ=$(yq '. | select(.kind == "Deployment") | .spec.template.spec.containers[0].resources.requests.cpu' amazon-generated.yaml)
          MEM_REQ=$(yq '. | select(.kind == "Deployment") | .spec.template.spec.containers[0].resources.requests.memory' amazon-generated.yaml)
          REPLICAS=$(yq '. | select(.kind == "Deployment") | .spec.replicas' amazon-generated.yaml)
          
          # Guardamos los valores limpios
          echo "cpu=$CPU_REQ" >> $GITHUB_OUTPUT
          echo "mem=$MEM_REQ" >> $GITHUB_OUTPUT
          echo "reps=$REPLICAS" >> $GITHUB_OUTPUT

      # --- PASO 4: DESPLIEGUE REAL (CON SALTO DE VALIDACI√ìN) ---
      - name: üöÄ Deploy to EKS
        run: |
          echo "Aplicando cambios al cl√∫ster..."
          # Usamos --validate=false solo como red de seguridad para esta conexi√≥n OIDC
          kubectl apply -f amazon-generated.yaml --validate=false
          
          # Confirmamos que las 6 r√©plicas suban correctamente
          kubectl rollout status deployment/amazon-deployment

      # --- PASO 5: NOTIFICACI√ìN EN SLACK ---
      - name: üì¢ Slack Notification
        if: always()
        uses: rtCamp/action-slack-notify@v2
        env:
          SLACK_WEBHOOK: ${{ secrets.SLACK_WEBHOOK_URL }}
          SLACK_CHANNEL: general
          SLACK_COLOR: ${{ job.status == 'success' && 'good' || 'danger' }}
          SLACK_ICON: https://kubernetes.io/images/favicon.png
          SLACK_TITLE: "üöÄ EKS Deployment: ${{ job.status }}"
          SLACK_MESSAGE: |
            *Cluster:* `cluster-sre-demo`
            *Namespace:* `default`
            *R√©plicas:* `${{ steps.specs.outputs.reps }}`
            *Reserva CPU:* `${{ steps.specs.outputs.cpu }}`
            *Reserva Memoria:* `${{ steps.specs.outputs.mem }}`
            
            *Resultado:* ${{ job.status == 'success' && '‚úÖ Despliegue Exitoso' || '‚ùå Error en el Pipeline' }}
            <https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}|Ver logs del proceso>
